
JMM的一些特性:
1.原子性:
	原子性是指的一个操作不能中断,即使在多线程一起执行的嗓唱,一个操作一旦开始,就不会被别的线程干扰.  比如一个静态变量int I ; 俩个线程同时为ta赋值,t1 set i=1; t2 set I =-1; 那么这个i,要么是1要么是-1. 这就是原子性.
2.可见性:
	可见性指的当一个线程修改了某一个共享变量的值,其他线程能能够立即知道这个修改.
	在串行中不会出现这个问题的,但是在并行系统中,就很有可能出现这个问题了.在cpu1和CPU2上面各运行一个线程,他们共享变量t,由于编译器优化的缘故,在cpu1上的线程将变量t进行了优化,将其缓存在cache或者寄存器中.这种情况下,如果在cpu2上的某个线程修改了t的值,那么cpu1上的线程可能无法意识到这个改动,依然读取cache或者寄存器里面的旧值.
3.有序性
	有序性,对于一个线程的执行代码而言,我们总是习惯性的以为代码是从先到后,从上到下的执行.给人的感觉确实如此.但是 我们忽略了一个指令重排序的问题.


第二章:java并行程序基础



线程状态:
	线程一般分为6中状态.
	New:表示刚刚new出来的一个线程
	runnable:可运行状态




上面这张图可以很清楚的说明问题啦.

新建线程
	新建线程是一件特别简单的事情,new Tread().start();调用start后会创建一个新的线程,并且执行run方法.
	注意:如果 new Thread().run() 这个相当于在主线程中,执行了一个对象的run方法而已,不会创建新的线程.因为java中是单继承的关系,所以继承的关系显得特别珍贵.所以我们可以有一个接口可以实现.实现了这个接口,去实现 run方法.这个需要配合new Thread(Runnable runnable)的接口.

Thread.currentThread().getName() 获取当前线程的名称.



终止线程
	
一般而言,线程的执行完毕后就会自动结束.无需手工关闭.但是 有时候也是需要手工关闭的.这时候呢 有一个stop()方法,但是这个jdk抛弃啦.

假设有俩个线程  t1 t2 他俩同时去操作  User 这个对象 这个对象有俩个属性  id /name 
t1在修改user的时候,肯定加锁啦.这时候T2只能处于等待状态. 但是t1.setId(1)之后, t1线程就被stop啦,这时候  线程就会把锁释放掉啦. T2在读的时候就发现 id是新的, 但是 name是旧的数据,这样是不可以的.

synchronized (i)  这句话的意思是,我要拿到i这个对象的锁,我才能进入下面的代码.















Thread.sleep(1000)  是让当前线程进行休眠一段时间,但是不会释放资源.
